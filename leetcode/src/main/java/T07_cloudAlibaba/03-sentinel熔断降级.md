[TOC]

## 1.熔断降级

### 1.熔断降级介绍

https://sentinelguard.io/zh-cn/docs/circuit-breaking.html

除了流量控制以外，对调用链路中不稳定的资源进行熔断降级也是保障高可用的重要措施之一。一个服务常常会调用别的模块，可能是另外的一个远程服务、数据库，或者第三方 API 等。例如，支付的时候，可能需要远程调用银联提供的 API；查询某个商品的价格，可能需要进行数据库查询。然而，这个被依赖服务的稳定性是不能保证的。如果依赖的服务出现了不稳定的情况，请求的响应时间变长，那么调用服务的方法的响应时间也会变长，线程会产生堆积，最终可能耗尽业务自身的线程池，服务本身也变得不可用。

![image-20211213205206882](https://cdn.jsdelivr.net/gh/hx1098/Algorithm@master/img/nacos/20211213205206.png)



现代微服务架构都是分布式的，由非常多的服务组成。不同服务之间相互调用，组成复杂的调用链路。以上的问题在链路调用中会产生放大的效果。复杂链路上的某一环不稳定，就可能会层层级联，最终导致整个链路都不可用。因此我们需要对不稳定的**弱依赖服务调用**进行熔断降级，暂时切断不稳定调用，避免局部不稳定因素导致整体的雪崩。**熔断降级作为保护自身的手段**，通常在客户端（调用端）进行配置。

> **注意**：本文档针对 Sentinel 1.8.0 及以上版本。1.8.0 版本对熔断降级特性进行了全新的改进升级，请使用最新版本以更好地利用熔断降级的能力。

### 2.熔断策略

Sentinel 提供以下几种熔断策略：

- 慢调用比例 (`SLOW_REQUEST_RATIO`)：选择以慢调用比例作为阈值，需要设置允许的慢调用 RT（即最大的响应时间），请求的响应时间大于该值则统计为慢调用。当单位统计时长（`statIntervalMs`）内请求数目大于设置的最小请求数目，并且慢调用的比例大于阈值，则接下来的熔断时长内请求会自动被熔断。经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN 状态），若接下来的一个请求响应时间小于设置的慢调用 RT 则结束熔断，若大于设置的慢调用 RT 则会再次被熔断。
- 异常比例 (`ERROR_RATIO`)：当单位统计时长（`statIntervalMs`）内请求数目大于设置的最小请求数目，并且异常的比例大于阈值，则接下来的熔断时长内请求会自动被熔断。经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN 状态），若接下来的一个请求成功完成（没有错误）则结束熔断，否则会再次被熔断。异常比率的阈值范围是 `[0.0, 1.0]`，代表 0% - 100%。
- 异常数 (`ERROR_COUNT`)：当单位统计时长内的异常数目超过阈值之后会自动进行熔断。经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN 状态），若接下来的一个请求成功完成（没有错误）则结束熔断，否则会再次被熔断。



### 3.熔断降级规则说明

熔断降级规则（DegradeRule）包含下面几个重要的属性：



|       Field        | 说明                                                         | 默认值     |
| :----------------: | :----------------------------------------------------------- | :--------- |
|      resource      | 资源名，即规则的作用对象                                     |            |
|       grade        | 熔断策略，支持慢调用比例/异常比例/异常数策略                 | 慢调用比例 |
|       count        | 慢调用比例模式下为慢调用临界 RT（超出该值计为慢调用）；异常比例/异常数模式下为对应的阈值 |            |
|     timeWindow     | 熔断时长，单位为 s                                           |            |
|  minRequestAmount  | 熔断触发的最小请求数，请求数小于该值时即使异常比率超出阈值也不会熔断（1.7.0 引入） | 5          |
|   statIntervalMs   | 统计时长（单位为 ms），如 60*1000 代表分钟级（1.8.0 引入）   | 1000 ms    |
| slowRatioThreshold | 慢调用比例阈值，仅慢调用比例模式有效（1.8.0 引入）           |            |



## 2.熔断策略-慢调用比例

1.最大RT: 最大响应时间,   请求的响应时间大于RT值, 则统计为慢调用.

2.当单位统计时长内请求的数目大于设置的最小请求数目, 并且慢调用的比例大于阈值, 则接下来的熔断时长内请求的会自动被熔断. 经过熔断时长后的熔断器会进入探测恢复状态(HALF-OPEN状态), 若接下的一个响应时间小于设置的慢调用RT, 则结束熔断, 若大于设置的慢调用RT,则继续熔断.

![image-20211214205548889](https://cdn.jsdelivr.net/gh/hx1098/Algorithm@master/img/nacos/20211214205548.png)

这么说吧,就好像家里的保险丝, 如上图所示:   

1. 如果过来10个请求, 5个失败, 比例阈值为0.5 > 0.1, 会触发熔断10S, , 

2. 10s之后, 又过来一个请求, 如果这个请求小于300ms, 就恢复正常, 否则继续熔断

代码:

```java
 @GetMapping("/testC")
    public String testC() throws InterruptedException {
        TimeUnit.SECONDS.sleep(5);//模拟慢调用
        log.info("currentThread is  testC::[{}]", Thread.currentThread().getName());
        return "testC------";
    }
```

Jmeter设置请求次数, 随后调用测试就会发现在调用期间会被熔断, 不在使用Jmeter调用后10后即可正常访问.

![image-20211214210751266](https://cdn.jsdelivr.net/gh/hx1098/Algorithm@master/img/nacos/20211214210751.png)



## 2.熔断策略-异常比例

跟上面的慢调用比例一模一样.

![image-20211214212750951](https://cdn.jsdelivr.net/gh/hx1098/Algorithm@master/img/nacos/20211214212751.png)



## 3.熔断策略-异常数

超过阈值后会进行熔断, 熔断时长过后会进入探测恢复状态, 如果接下来一个请求成功完成, 就结束熔断, 否则会被再次熔断.

注意: 异常降级只针对的是业务异常, 对Sentinel限流降级本身的异常(BlockException) 不生效



![image-20211214215135987](https://cdn.jsdelivr.net/gh/hx1098/Algorithm@master/img/nacos/20211214215136.png)

